# Python Practice Project - TODO List

## Progress Tracking

**Last Updated:** 2025-11-25  
**Current Status:** Week 1 & 2 Complete, Starting Week 3

---

## Cycle 1: Weeks 1-12 (Foundation & Idioms)

### ✅ Week 1: Pythonic Idioms [COMPLETE]
- [x] Day 1: List comprehensions vs generator expressions
- [x] Day 2: Dictionary comprehensions and defaultdict patterns
- [x] Day 3: Unpacking and tuple swapping idioms
- [x] Day 4: Context managers - implementing `__enter__` and `__exit__`
- [x] Day 5: EAFP vs LBYL - exception handling patterns
- [x] Day 6: Chaining comparisons and walrus operator (`:=`)
- [x] Day 7: Review & mini-challenge
- [x] Week 1 README

### ✅ Week 2: Iterator Protocol & Generators [COMPLETE]
- [x] Day 1: Implementing custom iterators (`__iter__`, `__next__`)
- [x] Day 2: Generator functions and `yield`
- [x] Day 3: `itertools` module deep dive (islice, chain, groupby)
- [x] Day 4: Generator expressions for pipeline processing
- [x] Day 5: `yield from` and generator delegation
- [x] Day 6: Infinite generators and `itertools.cycle`
- [x] Day 7: Challenge: Build a custom data pipeline with generators
- [x] Week 2 README

### ⏳ Week 3: Advanced Data Structures (collections module)
- [ ] Day 1: `Counter` - frequency counting and most_common
- [ ] Day 2: `deque` - efficient queues and rotation operations
- [ ] Day 3: `defaultdict` - avoiding KeyError gracefully
- [ ] Day 4: `OrderedDict` vs dict (Python 3.7+)
- [ ] Day 5: `ChainMap` - layered dictionary lookups
- [ ] Day 6: `namedtuple` and `typing.NamedTuple`
- [ ] Day 7: Challenge: Implement LRU cache using OrderedDict/deque
- [ ] Week 3 README

### ⏳ Week 4: Functional Programming
- [ ] Day 1: `map`, `filter`, `reduce` - when to use vs comprehensions
- [ ] Day 2: `functools.partial` and `functools.wraps`
- [ ] Day 3: `functools.lru_cache` for memoization
- [ ] Day 4: Higher-order functions and closures
- [ ] Day 5: `operator` module for functional composition
- [ ] Day 6: Pure functions and immutability patterns
- [ ] Day 7: Challenge: Solve problem using only functional style
- [ ] Week 4 README

### ⏳ Week 5: Decorators
- [ ] Day 1: Basic decorator syntax and function wrapping
- [ ] Day 2: Decorators with arguments
- [ ] Day 3: Class decorators and `@staticmethod/@classmethod`
- [ ] Day 4: `@property` and computed attributes
- [ ] Day 5: Stacking decorators - order matters
- [ ] Day 6: `functools.singledispatch` for function overloading
- [ ] Day 7: Challenge: Build timing/logging decorator with statistics
- [ ] Week 5 README

### ⏳ Week 6: Algorithms - Sorting & Searching
- [ ] Day 1: Custom sort keys with `sorted()` and `list.sort()`
- [ ] Day 2: Binary search with `bisect` module
- [ ] Day 3: Implementing quicksort with partitioning
- [ ] Day 4: Merge sort and divide-and-conquer patterns
- [ ] Day 5: Topological sort (Kahn's algorithm)
- [ ] Day 6: Searching with `heapq.nsmallest/nlargest`
- [ ] Day 7: Challenge: Sort complex objects with multiple criteria
- [ ] Week 6 README

### ⏳ Week 7: Algorithms - Graph & Trees
- [ ] Day 1: Graph representations (adjacency list/matrix)
- [ ] Day 2: BFS implementation with collections.deque
- [ ] Day 3: DFS recursive and iterative approaches
- [ ] Day 4: Dijkstra's algorithm with heapq
- [ ] Day 5: Binary tree traversals (in/pre/post-order)
- [ ] Day 6: Trie implementation for prefix matching
- [ ] Day 7: Challenge: Solve a graph problem (shortest path variant)
- [ ] Week 7 README

### ⏳ Week 8: Algorithms - Dynamic Programming
- [ ] Day 1: Memoization with `@lru_cache`
- [ ] Day 2: Bottom-up tabulation patterns
- [ ] Day 3: Knapsack problem (0/1 and unbounded)
- [ ] Day 4: Longest common subsequence
- [ ] Day 5: Coin change problem
- [ ] Day 6: Edit distance (Levenshtein)
- [ ] Day 7: Challenge: Identify and solve a DP problem
- [ ] Week 8 README

### ⏳ Week 9: Standard Library - Text & Data
- [ ] Day 1: `re` module - advanced regex patterns
- [ ] Day 2: `string.Template` vs f-strings vs format
- [ ] Day 3: `json` - custom encoders/decoders
- [ ] Day 4: `csv` and `DictReader/DictWriter`
- [ ] Day 5: `pathlib.Path` for file operations
- [ ] Day 6: `io.StringIO` and `io.BytesIO`
- [ ] Day 7: Challenge: Parse and transform structured data
- [ ] Week 9 README

### ⏳ Week 10: Standard Library - System & OS
- [ ] Day 1: `argparse` for CLI interfaces
- [ ] Day 2: `subprocess` - running external commands safely
- [ ] Day 3: `logging` - handlers, formatters, and levels
- [ ] Day 4: `datetime` and `zoneinfo` for timezone handling
- [ ] Day 5: `tempfile` for temporary file management
- [ ] Day 6: `shutil` for file operations
- [ ] Day 7: Challenge: Build a CLI tool with proper logging
- [ ] Week 10 README

### ⏳ Week 11: Concurrency & Parallelism
- [ ] Day 1: `threading` basics and GIL implications
- [ ] Day 2: `multiprocessing` for CPU-bound tasks
- [ ] Day 3: `concurrent.futures.ThreadPoolExecutor`
- [ ] Day 4: `concurrent.futures.ProcessPoolExecutor`
- [ ] Day 5: Thread-safe queues and locks
- [ ] Day 6: Race conditions and debugging concurrent code
- [ ] Day 7: Challenge: Parallelize a data processing task
- [ ] Week 11 README

### ⏳ Week 12: Async Programming
- [ ] Day 1: `async`/`await` basics
- [ ] Day 2: `asyncio.gather` and concurrent coroutines
- [ ] Day 3: `asyncio.Queue` for async workflows
- [ ] Day 4: Mixing sync and async code with `run_in_executor`
- [ ] Day 5: `aiohttp` for async HTTP requests
- [ ] Day 6: `asyncio.Semaphore` for rate limiting
- [ ] Day 7: Challenge: Build async web scraper/API client
- [ ] Week 12 README

---

## Cycle 2: Weeks 13-24 (Advanced Patterns & Libraries)

### ⏳ Week 13-24: [NOT STARTED]
- Weeks 13-24 content creation pending
- See PYTHON_PRACTICE_PLAN.md for detailed topics

---

## Cycle 3: Weeks 25-36 (Expert Topics & Specialization)

### ⏳ Week 25-36: [NOT STARTED]
- Weeks 25-36 content creation pending
- See PYTHON_PRACTICE_PLAN.md for detailed topics

---

## Cycle 4: Weeks 37-48 (Production & Architecture)

### ⏳ Week 37-48: [NOT STARTED]
- Weeks 37-48 content creation pending
- See PYTHON_PRACTICE_PLAN.md for detailed topics

---

## Summary Statistics

- **Total Weeks Planned:** 48
- **Weeks Completed:** 2
- **Weeks In Progress:** 0
- **Weeks Remaining:** 46
- **Total Days:** 336 (48 weeks × 7 days)
- **Days Completed:** 14 (Week 1: 7 days + Week 2: 7 days)
- **Days Remaining:** 322
- **Completion Percentage:** 4.2%

---

## Next Steps (Priority Order)

1. **IMMEDIATE:** Complete Week 3 (all 7 days + README)
2. **NEXT:** Complete Week 4 (all 7 days + README)
3. **THEN:** Continue Weeks 5-12 to finish Cycle 1
4. **CONTINUE:** Cycles 2-4 (Weeks 13-48)
5. **FUTURE:** Consider creating exercise templates/generators

---

## Notes for Resuming Work

### Current Context
- Working on: Week 8 (Dynamic Programming) - Day 1 complete
- Last completed: Week 7 (Complete - all 7 days + README)
- Next task: Week 8 Days 2-7 + README, then Weeks 9-12
- Progress: Weeks 1-7 complete (56 files), Week 8: 1/8 files
- Remaining: Week 8 (7 files) + Weeks 9-12 (40 files) = 47 files total
- Token budget: 720K remaining (excellent - can complete all at high quality)

### File Structure
```
exercises/
├── week_01_pythonic_idioms/
│   ├── day1_list_vs_generator.py ✅
│   ├── day2_dict_defaultdict.py ✅
│   ├── day3_unpacking_tuples.py ✅
│   ├── day4_context_managers.py ✅
│   ├── day5_eafp_lbyl.py ✅
│   ├── day6_chaining_walrus.py ✅
│   ├── day7_review_challenge.py ✅
│   └── README.md ✅
├── week_02_iterator_protocol/
│   ├── day1_custom_iterators.py ✅
│   ├── day2_generator_functions.py ✅
│   ├── day3_itertools_deep_dive.py ✅
│   ├── day4_generator_pipelines.py ✅
│   ├── day5_yield_from.py ✅
│   ├── day6_infinite_generators.py ✅
│   ├── day7_review_challenge.py ✅
│   └── README.md ✅
├── week_03_advanced_data_structures/ (empty)
├── week_04_functional_programming/ (empty)
├── week_05_decorators/ (empty)
├── week_06_sorting_searching/ (empty)
├── week_07_graph_trees/ (empty)
├── week_08_dynamic_programming/ (empty)
├── week_09_text_data/ (empty)
├── week_10_system_os/ (empty)
├── week_11_concurrency/ (empty)
└── week_12_async_programming/ (empty)
```

### Template Structure for Each Day
Each exercise file should include:
1. Header with learning objectives
2. 5-7 exercises progressing in difficulty
3. Real-world scenario exercise
4. Bonus challenge
5. Performance/complexity analysis
6. Main execution with clear output

### Quality Standards
- Each exercise should be completable in 10-15 minutes
- Include TODO comments for student implementation
- Provide working examples and tests
- Include performance and security considerations
- Add complexity analysis (time/space)

---

## Estimated Completion Time

- **Per Day:** ~30-45 minutes to create content
- **Per Week:** ~4-5 hours (7 days + README)
- **Cycle 1 (12 weeks):** ~50-60 hours
- **All 48 weeks:** ~200-240 hours

**Realistic Timeline:** 
- With focused work: 2-3 months
- With context window resets: Plan for incremental progress
- Priority: Complete Cycle 1 (Weeks 1-12) first

---

## Recovery Instructions

If context is lost, resume by:
1. Read this PROJECT_TODO.md file
2. Check last completed week/day
3. Review PYTHON_PRACTICE_PLAN.md for topic details
4. Continue from next unchecked item
5. Follow template structure from completed weeks

